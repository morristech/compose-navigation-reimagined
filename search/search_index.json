{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview A small and simple, yet fully fledged and customizable navigation library for Jetpack Compose : Full type-safety State restoration Nested navigation with independent backstacks Easy integration with BottomNavigation and TabRow Own lifecycle, saved state and view models for every backstack entry Animated transitions Navigation logic may be easily moved to the ViewModel layer No builders, no obligatory superclasses for your composables Quick start Add a single dependency to your project: implementation ( \"dev.olshevski.navigation:reimagined:1.1.0\" ) Define a set of screens. It is convenient to use a sealed class for this: sealed class Screen : Parcelable { @Parcelize object First : Screen () @Parcelize data class Second ( val id : Int ) : Screen () @Parcelize data class Third ( val text : String ) : Screen () } Create a composable with NavController , NavBackHandler and NavHost : @Composable fun NavHostScreen () { val navController = rememberNavController < Screen > ( startDestination = Screen . First ) NavBackHandler ( navController ) NavHost ( navController ) { screen -> when ( screen ) { Screen . First -> Column { Text ( \"First screen\" ) Button ( onClick = { navController . navigate ( Screen . Second ( id = 42 )) }) { Text ( \"To Second screen\" ) } } is Screen . Second -> Column { Text ( \"Second screen: ${ screen . id } \" ) Button ( onClick = { navController . navigate ( Screen . Third ( text = \"Hello\" )) }) { Text ( \"To Third screen\" ) } } is Screen . Third -> { Text ( \"Third screen: ${ screen . text } \" ) } } } } As you can see, NavController is used for switching between screens, NavBackHandler handles back presses and NavHost provides a composable corresponding to the last destination in the backstack. As simple as that.","title":"Overview"},{"location":"#overview","text":"A small and simple, yet fully fledged and customizable navigation library for Jetpack Compose : Full type-safety State restoration Nested navigation with independent backstacks Easy integration with BottomNavigation and TabRow Own lifecycle, saved state and view models for every backstack entry Animated transitions Navigation logic may be easily moved to the ViewModel layer No builders, no obligatory superclasses for your composables","title":"Overview"},{"location":"#quick-start","text":"Add a single dependency to your project: implementation ( \"dev.olshevski.navigation:reimagined:1.1.0\" ) Define a set of screens. It is convenient to use a sealed class for this: sealed class Screen : Parcelable { @Parcelize object First : Screen () @Parcelize data class Second ( val id : Int ) : Screen () @Parcelize data class Third ( val text : String ) : Screen () } Create a composable with NavController , NavBackHandler and NavHost : @Composable fun NavHostScreen () { val navController = rememberNavController < Screen > ( startDestination = Screen . First ) NavBackHandler ( navController ) NavHost ( navController ) { screen -> when ( screen ) { Screen . First -> Column { Text ( \"First screen\" ) Button ( onClick = { navController . navigate ( Screen . Second ( id = 42 )) }) { Text ( \"To Second screen\" ) } } is Screen . Second -> Column { Text ( \"Second screen: ${ screen . id } \" ) Button ( onClick = { navController . navigate ( Screen . Third ( text = \"Hello\" )) }) { Text ( \"To Third screen\" ) } } is Screen . Third -> { Text ( \"Third screen: ${ screen . text } \" ) } } } } As you can see, NavController is used for switching between screens, NavBackHandler handles back presses and NavHost provides a composable corresponding to the last destination in the backstack. As simple as that.","title":"Quick start"},{"location":"animations/","text":"Animations If you want to show animated transitions between destinations use AnimatedNavHost. The default transition is a simple crossfade, but you can granularly customize every transition with your own AnimatedNavHostTransitionSpec implementation. Here is one possible implementation of AnimatedNavHostTransitionSpec: val CustomTransitionSpec = AnimatedNavHostTransitionSpec < Any? > { action , _ , _ -> val direction = if ( action == NavAction . Pop ) { AnimatedContentScope . SlideDirection . End } else { AnimatedContentScope . SlideDirection . Start } slideIntoContainer ( direction ) with slideOutOfContainer ( direction ) } Set it into AnimatedNavHost: AnimatedNavHost ( controller = navController , transitionSpec = CustomTransitionSpec ) { destination -> // ... } and it'll end up looking like this: In AnimatedNavHostTransitionSpec you get the parameters: action - a hint about the last NavController method that changed the backstack from - a previous visible destination to - a target visible destination This information is plenty enough to choose a transition for every possible combination of screens and navigation actions. NavAction There are four default NavAction types: Pop , Replace and Navigate - objects that correspond to pop\u2026 , replace\u2026 , navigate methods of NavController Idle - the default action of a newly created NavController You can also create new action types by extending abstract NavAction class. Pass any of the type into setNewBackstack method of NavController and handle it in AnimatedNavHostTransitionSpec. The last action can also be accessed through action property of NavBackstack.","title":"Animations"},{"location":"animations/#animations","text":"If you want to show animated transitions between destinations use AnimatedNavHost. The default transition is a simple crossfade, but you can granularly customize every transition with your own AnimatedNavHostTransitionSpec implementation. Here is one possible implementation of AnimatedNavHostTransitionSpec: val CustomTransitionSpec = AnimatedNavHostTransitionSpec < Any? > { action , _ , _ -> val direction = if ( action == NavAction . Pop ) { AnimatedContentScope . SlideDirection . End } else { AnimatedContentScope . SlideDirection . Start } slideIntoContainer ( direction ) with slideOutOfContainer ( direction ) } Set it into AnimatedNavHost: AnimatedNavHost ( controller = navController , transitionSpec = CustomTransitionSpec ) { destination -> // ... } and it'll end up looking like this: In AnimatedNavHostTransitionSpec you get the parameters: action - a hint about the last NavController method that changed the backstack from - a previous visible destination to - a target visible destination This information is plenty enough to choose a transition for every possible combination of screens and navigation actions.","title":"Animations"},{"location":"animations/#navaction","text":"There are four default NavAction types: Pop , Replace and Navigate - objects that correspond to pop\u2026 , replace\u2026 , navigate methods of NavController Idle - the default action of a newly created NavController You can also create new action types by extending abstract NavAction class. Pass any of the type into setNewBackstack method of NavController and handle it in AnimatedNavHostTransitionSpec. The last action can also be accessed through action property of NavBackstack.","title":"NavAction"},{"location":"back-handling/","text":"Back handling Back handling in the library is opt-in, rather than opt-out. By itself, neither NavController nor NavHost handles the back button press. You can add NavBackHandler or usual BackHandler in order to react to back presses where you need to. NavBackHandler is the most basic implementation of BackHandler - it calls pop only when there are more than one item in the backstack. When there is only one backstack item left, NavBackHandler is disabled, and any upper-level BackHandler may take its turn to react to back button presses. If you want to specify your own backstack logic, use BackHandler directly. For example, this is how back navigation is handled for BottomNavigation in the sample : @Composable private fun BottomNavigationBackHandler ( navController : NavController < BottomNavigationDestination > ) { BackHandler ( enabled = navController . backstack . entries . size > 1 ) { val lastEntry = navController . backstack . entries . last () if ( lastEntry . destination == BottomNavigationDestination . values () [ 0 ] ) { // The start destination should always be the last to pop. We move // it to the start to preserve its saved state and view models. navController . moveLastEntryToStart () } else { navController . pop () } } } Warning Always place your NavBackHandler/BackHandler before the corresponding NavHost. As both BackHandler and NavHost use Lifecycle under the hood, there is a case when the order of back handling may be restored incorrectly after a process/activity recreation. This is how the framework works and there is nothing to do about it. Simple placement of BackHandler before NavHost guarantees no issues in this part.","title":"Back handling"},{"location":"back-handling/#back-handling","text":"Back handling in the library is opt-in, rather than opt-out. By itself, neither NavController nor NavHost handles the back button press. You can add NavBackHandler or usual BackHandler in order to react to back presses where you need to. NavBackHandler is the most basic implementation of BackHandler - it calls pop only when there are more than one item in the backstack. When there is only one backstack item left, NavBackHandler is disabled, and any upper-level BackHandler may take its turn to react to back button presses. If you want to specify your own backstack logic, use BackHandler directly. For example, this is how back navigation is handled for BottomNavigation in the sample : @Composable private fun BottomNavigationBackHandler ( navController : NavController < BottomNavigationDestination > ) { BackHandler ( enabled = navController . backstack . entries . size > 1 ) { val lastEntry = navController . backstack . entries . last () if ( lastEntry . destination == BottomNavigationDestination . values () [ 0 ] ) { // The start destination should always be the last to pop. We move // it to the start to preserve its saved state and view models. navController . moveLastEntryToStart () } else { navController . pop () } } } Warning Always place your NavBackHandler/BackHandler before the corresponding NavHost. As both BackHandler and NavHost use Lifecycle under the hood, there is a case when the order of back handling may be restored incorrectly after a process/activity recreation. This is how the framework works and there is nothing to do about it. Simple placement of BackHandler before NavHost guarantees no issues in this part.","title":"Back handling"},{"location":"dialogs/","text":"Dialogs If you need to handle a backstack of dialogs in your application, simply add a DialogNavHost to the same composition layer where your regular NavHost lives. This way you may show and control the backstack of regular screen destination, as well as a second backstack of Dialogs: @Composable fun NavHostScreen () { val navController = rememberNavController < ScreenDestination > ( startDestination = ScreenDestination . First , ) val dialogController = rememberNavController < DialogDestination > ( initialBackstack = emptyList () ) NavBackHandler ( navController ) NavHost ( navController ) { destination -> when ( destination ) { ScreenDestination . First -> { /* ... */ } ScreenDestination . Second -> { /* ... */ } } } DialogNavHost ( dialogController ) { destination -> Dialog ( onDismissRequest = { dialogController . pop () }) { when ( destination ) { DialogDestination . First -> { /* ... */ } DialogDestination . Second -> { /* ... */ } } } } } DialogNavHost DialogNavHost is an alternative version of NavHost that is better suited for showing dialogs. It is based on AnimatedNavHost and provides smoother transition between dialogs without any scrim/fade flickering: And this is how it looks in the regular NavHost: DialogNavHost definitely wins this battle. Note DialogNavHost doesn't wrap your composables into a Dialog. You need to use either Dialog or AlertDialog composable inside a contentSelector yourself.","title":"Dialogs"},{"location":"dialogs/#dialogs","text":"If you need to handle a backstack of dialogs in your application, simply add a DialogNavHost to the same composition layer where your regular NavHost lives. This way you may show and control the backstack of regular screen destination, as well as a second backstack of Dialogs: @Composable fun NavHostScreen () { val navController = rememberNavController < ScreenDestination > ( startDestination = ScreenDestination . First , ) val dialogController = rememberNavController < DialogDestination > ( initialBackstack = emptyList () ) NavBackHandler ( navController ) NavHost ( navController ) { destination -> when ( destination ) { ScreenDestination . First -> { /* ... */ } ScreenDestination . Second -> { /* ... */ } } } DialogNavHost ( dialogController ) { destination -> Dialog ( onDismissRequest = { dialogController . pop () }) { when ( destination ) { DialogDestination . First -> { /* ... */ } DialogDestination . Second -> { /* ... */ } } } } }","title":"Dialogs"},{"location":"dialogs/#dialognavhost","text":"DialogNavHost is an alternative version of NavHost that is better suited for showing dialogs. It is based on AnimatedNavHost and provides smoother transition between dialogs without any scrim/fade flickering: And this is how it looks in the regular NavHost: DialogNavHost definitely wins this battle. Note DialogNavHost doesn't wrap your composables into a Dialog. You need to use either Dialog or AlertDialog composable inside a contentSelector yourself.","title":"DialogNavHost"},{"location":"nav-controller/","text":"NavController This is the main control point of navigation. It keeps record of all current backstack entries and preserves them on activity/process recreation. NavController may be created with rememberNavController method within composition or with navController outside of it. The latter may be used for storing NavController in a ViewModel. As it implements Parcelable interface, it may be (and should be) stored in a SavedStateHandle . Both rememberNavController and navController methods accept startDestination as a parameter: val navController = rememberNavController < Screen > ( startDestination = Screen . First ) If you want to create NavController with an arbitrary number of backstack items, you may use initialBackstack parameter instead: val navController = rememberNavController < Screen > ( initialBackstack = listOf ( Screen . First , Screen . Second , Screen . Third ) ) Screen.Third will become the currently displayed item. Screen.First and Screen.Second will be stored in the backstack. NavController in a ViewModel The library provides a property delegate for creating and saving NavController in a SavedStateHandle: class NavigationViewModel ( savedStateHandle : SavedStateHandle ) : ViewModel () { val navController by savedStateHandle . navController < Screen > ( startDestination = Screen . First ) } Destinations NavController accepts all types meeting the requirements as destinations. The requirements are: The type must be writable to Parcel - it could be Parcelable, Serializable, string/primitive or other supported type. The type must be either Stable , or Immutable , or string/primitive type. Other than that, you are not limited to any particular type. Tip It is very convenient to define your set of destinations as a sealed class or enum. This way you will always be notified by the compiler that you have a non-exhaustive when statement if you add a new destination. Tip You may also define your own base interface for destinations, for example: interface Screen : Parcelable { val title : String @Composable fun Content () } This way you may handle your destinations without checking for their particular instances. NavEntry NavEntry wraps around every destination passed into NavController and provides a unique identifier to each of them. Every unique entry in the backstack then gets its own independent lifecycle, saved state and ViewModelStore. In other words, if you add 2 or more equal destination to the backstack, they will get their own separate identity and a set of components. Saved state and view models of each entry are guaranteed to be preserved for as long as the entry is present in the backstack. Navigation methods There is a handful of pre-defined methods suitable for basic app navigation: navigate , moveToTop , pop , popUpTo , popAll , replaceLast , replaceUpTo , replaceAll . They all should be pretty much self-explanatory. But let's go into details about some of them: moveToTop This method searches for some particular destination in the backstack and, as the method says, moves it to the top. This is particularly useful for integration with BottomNavigation/TabRow, when you want to always keep a single instance of every destination in the backstack. The method is expected to be used in pair with navigate : if ( ! navController . moveToTop { it is SomeDestination }) { // navigate to a new destination if there is no existing one navController . navigate ( SomeDestination ()) } You may see how it is used for BottomNavigation in the sample . Methods with a search predicate moveToTop , popUpTo , replaceUpTo - all these methods require the predicate parameter to be specified. It provides a selection condition for a destination to search for. In case multiple destinations match the predicate, you may specify the match parameter. Match.Last is the default value and in this case the last matching item from the start of the backstack will be selected. Alternatively, you may use Match.First . New custom methods If your use-case calls for some advanced backstack manipulations, you may use setNewBackstack method. It is in fact the only public method defined in NavController, all other methods are provided as extensions and use setNewBackstack under the hood. Here is how a new extension method moveLastEntryToStart is implemented in the sample : fun NavController < BottomNavigationDestination > . moveLastEntryToStart () { setNewBackstack ( entries = backstack . entries . toMutableList (). also { val entry = it . removeLast () it . add ( 0 , entry ) }, action = NavAction . Pop ) } NavBackstack You may access current backstack entries and the last NavAction through backstack property of NavController. This property is backed up by MutableState and any changes to it will notify composition. If you want to listen for backstack changes outside of composition you may set onBackstackChange listener of NavController.","title":"NavController"},{"location":"nav-controller/#navcontroller","text":"This is the main control point of navigation. It keeps record of all current backstack entries and preserves them on activity/process recreation. NavController may be created with rememberNavController method within composition or with navController outside of it. The latter may be used for storing NavController in a ViewModel. As it implements Parcelable interface, it may be (and should be) stored in a SavedStateHandle . Both rememberNavController and navController methods accept startDestination as a parameter: val navController = rememberNavController < Screen > ( startDestination = Screen . First ) If you want to create NavController with an arbitrary number of backstack items, you may use initialBackstack parameter instead: val navController = rememberNavController < Screen > ( initialBackstack = listOf ( Screen . First , Screen . Second , Screen . Third ) ) Screen.Third will become the currently displayed item. Screen.First and Screen.Second will be stored in the backstack.","title":"NavController"},{"location":"nav-controller/#navcontroller-in-a-viewmodel","text":"The library provides a property delegate for creating and saving NavController in a SavedStateHandle: class NavigationViewModel ( savedStateHandle : SavedStateHandle ) : ViewModel () { val navController by savedStateHandle . navController < Screen > ( startDestination = Screen . First ) }","title":"NavController in a ViewModel"},{"location":"nav-controller/#destinations","text":"NavController accepts all types meeting the requirements as destinations. The requirements are: The type must be writable to Parcel - it could be Parcelable, Serializable, string/primitive or other supported type. The type must be either Stable , or Immutable , or string/primitive type. Other than that, you are not limited to any particular type. Tip It is very convenient to define your set of destinations as a sealed class or enum. This way you will always be notified by the compiler that you have a non-exhaustive when statement if you add a new destination. Tip You may also define your own base interface for destinations, for example: interface Screen : Parcelable { val title : String @Composable fun Content () } This way you may handle your destinations without checking for their particular instances.","title":"Destinations"},{"location":"nav-controller/#naventry","text":"NavEntry wraps around every destination passed into NavController and provides a unique identifier to each of them. Every unique entry in the backstack then gets its own independent lifecycle, saved state and ViewModelStore. In other words, if you add 2 or more equal destination to the backstack, they will get their own separate identity and a set of components. Saved state and view models of each entry are guaranteed to be preserved for as long as the entry is present in the backstack.","title":"NavEntry"},{"location":"nav-controller/#navigation-methods","text":"There is a handful of pre-defined methods suitable for basic app navigation: navigate , moveToTop , pop , popUpTo , popAll , replaceLast , replaceUpTo , replaceAll . They all should be pretty much self-explanatory. But let's go into details about some of them:","title":"Navigation methods"},{"location":"nav-controller/#movetotop","text":"This method searches for some particular destination in the backstack and, as the method says, moves it to the top. This is particularly useful for integration with BottomNavigation/TabRow, when you want to always keep a single instance of every destination in the backstack. The method is expected to be used in pair with navigate : if ( ! navController . moveToTop { it is SomeDestination }) { // navigate to a new destination if there is no existing one navController . navigate ( SomeDestination ()) } You may see how it is used for BottomNavigation in the sample .","title":"moveToTop"},{"location":"nav-controller/#methods-with-a-search-predicate","text":"moveToTop , popUpTo , replaceUpTo - all these methods require the predicate parameter to be specified. It provides a selection condition for a destination to search for. In case multiple destinations match the predicate, you may specify the match parameter. Match.Last is the default value and in this case the last matching item from the start of the backstack will be selected. Alternatively, you may use Match.First .","title":"Methods with a search predicate"},{"location":"nav-controller/#new-custom-methods","text":"If your use-case calls for some advanced backstack manipulations, you may use setNewBackstack method. It is in fact the only public method defined in NavController, all other methods are provided as extensions and use setNewBackstack under the hood. Here is how a new extension method moveLastEntryToStart is implemented in the sample : fun NavController < BottomNavigationDestination > . moveLastEntryToStart () { setNewBackstack ( entries = backstack . entries . toMutableList (). also { val entry = it . removeLast () it . add ( 0 , entry ) }, action = NavAction . Pop ) }","title":"New custom methods"},{"location":"nav-controller/#navbackstack","text":"You may access current backstack entries and the last NavAction through backstack property of NavController. This property is backed up by MutableState and any changes to it will notify composition. If you want to listen for backstack changes outside of composition you may set onBackstackChange listener of NavController.","title":"NavBackstack"},{"location":"nav-host/","text":"NavHost NavHost is a composable that shows the last entry of a backstack and provides all components associated with this particular entry: Lifecycle , SavedStateRegistry and ViewModelStore . All these components are provided through CompositionLocalProvider within their corresponding owners LocalLifecycleOwner , LocalSavedStateRegistryOwner and LocalViewModelStoreOwner . The components are kept around until its associated entry is removed from the backstack (or until the parent entry containing the current child NavHost is removed). NavHost by itself doesn't provide any animated transitions, it simply jump-cuts to the next destination:","title":"NavHost"},{"location":"nav-host/#navhost","text":"NavHost is a composable that shows the last entry of a backstack and provides all components associated with this particular entry: Lifecycle , SavedStateRegistry and ViewModelStore . All these components are provided through CompositionLocalProvider within their corresponding owners LocalLifecycleOwner , LocalSavedStateRegistryOwner and LocalViewModelStoreOwner . The components are kept around until its associated entry is removed from the backstack (or until the parent entry containing the current child NavHost is removed). NavHost by itself doesn't provide any animated transitions, it simply jump-cuts to the next destination:","title":"NavHost"},{"location":"return-results/","text":"Return results As destination types are not strictly required to be Immutable, you may change them while they are in the backstack. This may be used for returning values from other destinations. Just make a mutable property backed up by mutableStateOf and change it when required. For example, we want to return a string from the second screen. Here is how destinations may be defined: interface AcceptsResultFromSecond { val resultFromSecond : MutableState < String? > } @Stable sealed class NavHostDestination : Parcelable { @Parcelize data class First ( override val resultFromSecond : @RawValue MutableState < String? > = mutableStateOf ( null ) ) : NavHostDestination (), AcceptsResultFromSecond @Parcelize object Second : NavHostDestination () } And to actually set the result from the Second screen you do: val previousDestination = navController . backstack . entries . let { it [ it . lastIndex - 1 ] . destination } check ( previousDestination is AcceptsResultFromSecond ) previousDestination . resultFromSecond . value = text navController . pop () You may see how it is implemented in the sample here . Warning In general, returning values to previous destinations makes the navigation logic more complicated. Also, this approach doesn't guarantee full compile time type-safety. Use it with caution and when you are sure what you are doing. Sometimes it may be easier to use a shared state holder.","title":"Return results"},{"location":"return-results/#return-results","text":"As destination types are not strictly required to be Immutable, you may change them while they are in the backstack. This may be used for returning values from other destinations. Just make a mutable property backed up by mutableStateOf and change it when required. For example, we want to return a string from the second screen. Here is how destinations may be defined: interface AcceptsResultFromSecond { val resultFromSecond : MutableState < String? > } @Stable sealed class NavHostDestination : Parcelable { @Parcelize data class First ( override val resultFromSecond : @RawValue MutableState < String? > = mutableStateOf ( null ) ) : NavHostDestination (), AcceptsResultFromSecond @Parcelize object Second : NavHostDestination () } And to actually set the result from the Second screen you do: val previousDestination = navController . backstack . entries . let { it [ it . lastIndex - 1 ] . destination } check ( previousDestination is AcceptsResultFromSecond ) previousDestination . resultFromSecond . value = text navController . pop () You may see how it is implemented in the sample here . Warning In general, returning values to previous destinations makes the navigation logic more complicated. Also, this approach doesn't guarantee full compile time type-safety. Use it with caution and when you are sure what you are doing. Sometimes it may be easier to use a shared state holder.","title":"Return results"},{"location":"view-models/","text":"ViewModels Every unique NavEntry in NavHost provides its own ViewModelStore. Every such ViewModelStores is guaranteed to exist for as long as the associated NavEntry is present in the backstack. As soon as NavEntry is removed from the backstack, its ViewModelStore with all ViewModels is cleared. You can get ViewModels as you do it usually, by using composable viewModel from androidx.lifecycle:lifecycle-viewmodel-compose artifact, for example: @Composable fun SomeScreen () { val someViewModel = viewModel < SomeViewModel > () // ... } Passing parameters into a ViewModel There is no such thing as a Bundle of arguments for navigation entries in this library. This means that there is literally nothing to pass into SavedStateHandle of your ViewModel as the default arguments. I personally recommend passing all parameters into a ViewModel constructor directly. This keeps everything clean and type-safe. For this you may use my Easy Factories library that simplifies the creation of ViewModels with arbitrary parameters. If you use dependency injections in your project, explore the samples that show how to pass parameters into a ViewModel and inject all other dependencies: Dagger/Anvil/Hilt use a combination of Easy Factories library mentioned above and @AssistedInject Koin supports ViewModel parameters out of the box and does it charmingly simple","title":"ViewModels"},{"location":"view-models/#viewmodels","text":"Every unique NavEntry in NavHost provides its own ViewModelStore. Every such ViewModelStores is guaranteed to exist for as long as the associated NavEntry is present in the backstack. As soon as NavEntry is removed from the backstack, its ViewModelStore with all ViewModels is cleared. You can get ViewModels as you do it usually, by using composable viewModel from androidx.lifecycle:lifecycle-viewmodel-compose artifact, for example: @Composable fun SomeScreen () { val someViewModel = viewModel < SomeViewModel > () // ... }","title":"ViewModels"},{"location":"view-models/#passing-parameters-into-a-viewmodel","text":"There is no such thing as a Bundle of arguments for navigation entries in this library. This means that there is literally nothing to pass into SavedStateHandle of your ViewModel as the default arguments. I personally recommend passing all parameters into a ViewModel constructor directly. This keeps everything clean and type-safe. For this you may use my Easy Factories library that simplifies the creation of ViewModels with arbitrary parameters. If you use dependency injections in your project, explore the samples that show how to pass parameters into a ViewModel and inject all other dependencies: Dagger/Anvil/Hilt use a combination of Easy Factories library mentioned above and @AssistedInject Koin supports ViewModel parameters out of the box and does it charmingly simple","title":"Passing parameters into a ViewModel"}]}